using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/*     Soler            Assingment 4
 *          The fact that I have to make this into a runnable app is gonna take
 *      Waaay too much time. Tally Ho!
 *  
 *  Revision History
 *  2019-11-06 Created
 *  2019-11-07 Building methods for generating search results.
 *  2019-11-13 Continuing search results, finished finding max index. Buiding output engine.. this will be useful for later projects.
 *  2019-11-14 Con't on output engine as i call it, a bit of testing but not much.
 */
namespace Assingment4
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] x = new string[]  { "Test", "AAAAAAA!", "NO", "OOPS 12312351245 9 99 9 9 21029381234          4" };

            outputConstructor test = new outputConstructor();
            test.currentScreen = x;
            test.printScreen();
            Console.ReadLine();
        }

        //Takes an array of strings and puts a box around it

        public class outputConstructor
        {

            public char boxTop;
            public char boxSides;
            public char boxBot;
            private int length; //num of characters before output cuts off or loops.
            private int height; //0 is auto, any other number fixes the height
            private bool wrap;

            public string[] currentScreen;
            private int cursor;

            
            public outputConstructor()
            {
                this.boxTop = '=';
                this.boxSides = '|';
                this.boxBot = '=';
                this.length = 20;
                this.wrap = true;
                this.height = 0;
                this.currentScreen = new string[this.length];
                this.cursor = 0;
            }

            public outputConstructor(int _length, bool _wrap)
            {
                this.boxTop = '=';
                this.boxSides = '|';
                this.boxBot = '=';
                this.length = Math.Abs(_length);
                this.wrap = _wrap;
            }

            private void loopCursor()
            {
                cursor %= length;
            }

            private void incrementCursor(int value)
            {
                cursor += value;
                loopCursor();
            }

            public void printScreen()
            {
                Console.Clear();
                string[] output = Boxify(this.currentScreen);
                
                foreach(string str in output)
                {
                    Console.WriteLine(str);
                }
            }

            public void clearCurrentScreen()
            {
                this.currentScreen = new string[currentScreen.Length];
                this.cursor = 0;
                
            }

            public int menu(string message, Boolean isLoop)
            {
                int x = 0;
                do
                {
                    
                    try
                    {

                    }
                    catch (Exception)
                    {
                        Console.WriteLine("Bad input.");
                    }
                } while (isLoop);
            }

            public void append(string line)
            {
                if (wrap)
                {
                    
                }
                else
                {

                }
            }

            

            
            private void insert(string line, int location)
            {
                this.cursor = location;
                
                this.currentScreen[cursor] = line;
                this.incrementCursor(1);
            }

            private void insert(string[] line, int location)
            {
                for(int x = 0; x < line.Length; x++)
                {
                    insert(line[x], location);
                }
            }

            private List<string> wrapString(string input)
            {
                List<string> listOutput = new List<string>();

                while (input.Length > 0)
                {
                    string tempString = "";

                    for(int x = 0; (input.Length > 0)&&(x < this.length); x++)
                    {
                        tempString += input[0];
                        input.Remove(0,1);
                    }

                    listOutput.Add(tempString);
                    
                    
                }

                return listOutput;
            }
            /// <summary>
            /// Cuts a string to set length of the output.
            /// </summary>
            /// <param name="input"></param>
            /// <returns>Output at correct max length (not wrapped)</returns>
            private string shearString(string input) 
            {
                string strOutput = "";
                for(int x = 0; (x < this.length) && (x < input.Length); x++)
                {
                    strOutput += input[x];
                }
                return strOutput;
            }
            /// <summary>
            /// Shearstring but an array.
            /// </summary>
            /// <param name="input"></param>
            /// <returns></returns>
            private string[] shearString(string[] input)
            {
                string[] strOutput = new string[input.Length];
                for(int i = 0; i < input.Length; i++){ 
                    for (int x = 0; (x < this.length) && (x < input.Length); x++)
                    {
                        strOutput[i] += input[i][x];
                    }
                
                }
                return strOutput;
            }

            //public void AddLine(string _output)
            //{
            //    if (this.wrap)
            //    {
            //        List<string> output = wrapString(_output);
            //    }
            //    else
            //    {
            //        shearString(_output){

            //        }
            //    }
            //}

            /// <summary>
            /// puts a box around an array of strings.
            /// 
            /// </summary>
            /// <param name="input">Input string to put box around</param>
            /// <returns>same array, with a box around it</returns>
            public string[] Boxify(string[] input)
            {
                
                const int Offet = 2;
                int maxLength = 0;
                string[] output;
                foreach (string i in input)
                {
                    if (maxLength < i.Length)
                    {
                        maxLength = i.Length;
                    }
                }

                output = new string[input.Length + Offet];
                output[0] = RepeatChar(maxLength + Offet, this.boxTop);
                output[output.Length - 1] = RepeatChar(maxLength + Offet, this.boxBot);

                for (int i = 1; i < output.Length - 1; i++)
                {
                    foreach (char c in input[i - 1])
                    {
                        output[i] += c;
                    }
                    output[i] = FillEmptySpace(output[i], maxLength);

                    output[i] = this.boxSides + output[i] + this.boxSides;

                }

                return output;

            }

            /// <summary>
            /// Hacky version of boxify, this just has a set length.
            /// (it cuts off anything greater than the length)
            /// </summary>
            /// <param name="input">Arrray of strings to put box around</param>
            /// <param name="length">lenght of box</param>
            /// <returns>Array of strings with box around it.</returns>
            public string[] Boxify(string[] input, int length)
            {

                const int Offet = 2;
                int maxLength = length;
                string[] output;
                //foreach (string i in input)
                //{
                //    if (maxLength < i.Length)
                //    {
                //        maxLength = i.Length;
                //    }
                //}
                input = shearString(input);

                output = new string[input.Length + Offet];
                output[0] = RepeatChar(maxLength + Offet, this.boxTop);
                output[output.Length - 1] = RepeatChar(maxLength + Offet, this.boxBot);

                for (int i = 1; i < output.Length - 1; i++)
                {
                    foreach (char c in input[i - 1])
                    {
                        output[i] += c;
                    }
                    output[i] = FillEmptySpace(output[i], maxLength);

                    output[i] = this.boxSides + output[i] + this.boxSides;

                }

                return output;

            }

            public static string FillEmptySpace(string input, int length)
            {
                int x = 0;
                string output = "";

                if (input.Length > length)
                {
                    throw new IndexOutOfRangeException("String Length is greater than empty space length.");
                }

                foreach (char c in input)
                {
                    output += c;


                    x++;
                }
                while (x < length)
                {
                    output += " ";
                    x++;
                }

                return output;
            }
            public static string RepeatChar(int length, char character)
            {
                string output = "";
                for (int x = 0; x < length; x++)
                {
                    output += character;
                }

                return output;
            }
        }



        public class SeatingPlan
        {
            private string[,] seats;

            public class seat
            {
                string name;
                int xcord;
                int ycord;
            }

            public SeatingPlan(int height, int width)
            {
                this.seats = new string[height, width];

            }


            //Seach function, this takes the given name and tries to find the most similar name.
            //return index of chosen name
            public seat[] searchSeat(string query)
            {
                int Length = this.seats.GetLength(0);
                int Width = this.seats.GetLength(1);
                double[,] queryAccuracy = new double[Length, Width];
                //double queryAccuracy;

                int[,] possibleHits = new int[5, 2];


                int numHits = 5;
                for (int x = 0; x < Length; x++)
                {
                    for (int y = 0; y < Width; y++)
                    {
                        queryAccuracy[x,y] = CalculateSimilarity(seats[x, y], query);

                        
                    }
                }


                return null;//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEELETE THIS AAAAAAAAAAAAAAAA



            }


            /// <summary>
            /// Takes 2D double arrray and finds the largest elements
            /// </summary>
            /// <param name="_queryAccuracy"></param>
            /// <param name="numResults"></param>
            /// <returns>index value for largest array.</returns>
            public int[,] getMaxIndex(double[,] _queryAccuracy, int numResults)
            {
                const int empty = -1;
                int[,] maxResults = new int[5, 2];

                Populate(ref maxResults, empty);

                int Length = _queryAccuracy.GetLength(0);
                int Width = _queryAccuracy.GetLength(1);

                for (int i = 0; i < Length; i++)
                {
                    for (int j = 0; j < Width; j++)
                    {
                        for (int k = 0; k < maxResults.Length; k++)
                        {
                            if ((maxResults[k, 0] == empty) || (maxResults[k, 1] == empty))
                            {
                                maxResults[k, 0] = i;
                                maxResults[k, 1] = j;
                                break;
                            }
                            else if (_queryAccuracy[i, j] > _queryAccuracy[maxResults[k,0], maxResults[k,1]])
                            {
                                maxResults[k, 0] = i;
                                maxResults[k, 1] = j;
                                break;
                            }
                        }
                    }
                }


                return maxResults;
            }
            

            //private void insertMaxIndexDown(ref int[,] maxIndex, int index, int x_cord, int y_cord)
            //{
            //    maxIndex[_maxIndex.GetLength(0), 0] == 0;
            //    maxIndex[_maxIndex.GetLength(0), 0] == 1;
            //    //Creates space for inserted index
            //    for (int x = _maxIndex.GetLength(0) - 1; x >= index; x--)
            //    {
            //        if(maxIndex[x] )
            //        maxIndex[x]
            //    }
            //}

            //****************************************Possibly Redundant*******************
            /// <summary>
            /// Just a bubble sort for max index. should only work within class.
            /// </summary>
            /// <param name="maxIndex"></param>
            private void sortMaxIndex(ref int[,] maxIndex, double[,] resultsToSort)
            {
                int[] placeholder;
                bool isDone;
                do
                {
                    isDone = true;
                    for (int x = 0; x < maxIndex.Length - 1; x++)
                    {
                        if (resultsToSort[maxIndex[x, 0], maxIndex[x, 1]] < resultsToSort[maxIndex[x + 1, 0], maxIndex[x + 1, 1]])
                        {
                            placeholder = new int[] { maxIndex[x + 1, 0], maxIndex[x + 1, 1] };

                            maxIndex[x + 1, 0] = maxIndex[x, 0];
                            maxIndex[x + 1, 1] = maxIndex[x, 1];


                            maxIndex[x, 0] = placeholder[0];
                            maxIndex[x, 1] = placeholder[1];

                            isDone = false;
                        }
                    }

                } while (!isDone);
            }

            private void Populate(ref int[,] array, int value)
            {
                for(int x = 0; x < array.GetLength(0); x++)
                {
                    for(int y =0; y < array.GetLength(1); y++)
                    {
                        array[x, y] = value;
                    }
                }
            }

            //public int[] findSeat(string name)
            //{
                
            //}


            public bool isPlanFull()
            {
                for (int x = 0; x < seats.GetLength(0); x++)
                {
                    for (int y = 0; y < seats.GetLength(1); y++)
                    {
                        if (this.isEmpty(x, y))
                        {
                            return false;
                        }
                    }
                }

                return true;
            }
            public bool tryAddSeat(string name, int xcord, int ycord)
            {
                try
                {
                    if (this.isEmpty(xcord, ycord))
                    {
                        AddSeat(name, xcord, ycord);
                        return true;
                    }
                    else
                    {
                        return false;
                    }

                }
                catch(Exception e)
                {
                    return false;
                }
            }
            public void AddSeat(string name, int xcord, int ycord)
            {
                this.seats[xcord, ycord] = name;
            }

            public bool isEmpty(int xcord, int ycord)
            {
                if (string.IsNullOrEmpty(this.seats[xcord, ycord]))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }


            // Copied code to compare two strings.
            //*****************************************************************************************************************
            /// <summary>
            /// Returns the number of steps required to transform the source string
            /// into the target string.
            /// </summary>
            private int ComputeLevenshteinDistance(string source, string target)
            {
                if ((source == null) || (target == null)) return 0;
                if ((source.Length == 0) || (target.Length == 0)) return 0;
                if (source == target) return source.Length;

                int sourceWordCount = source.Length;
                int targetWordCount = target.Length;

                // Step 1
                if (sourceWordCount == 0)
                    return targetWordCount;

                if (targetWordCount == 0)
                    return sourceWordCount;

                int[,] distance = new int[sourceWordCount + 1, targetWordCount + 1];

                // Step 2
                for (int i = 0; i <= sourceWordCount; distance[i, 0] = i++) ;
                for (int j = 0; j <= targetWordCount; distance[0, j] = j++) ;

                for (int i = 1; i <= sourceWordCount; i++)
                {
                    for (int j = 1; j <= targetWordCount; j++)
                    {
                        // Step 3
                        int cost = (target[j - 1] == source[i - 1]) ? 0 : 1;

                        // Step 4
                        distance[i, j] = Math.Min(Math.Min(distance[i - 1, j] + 1, distance[i, j - 1] + 1), distance[i - 1, j - 1] + cost);
                    }
                }

                return distance[sourceWordCount, targetWordCount];
            }

            /// <summary>
            /// Calculate percentage similarity of two strings
            /// <param name="source">Source String to Compare with</param>
            /// <param name="target">Targeted String to Compare</param>
            /// <returns>Return Similarity between two strings from 0 to 1.0</returns>
            /// </summary>
            double CalculateSimilarity(string source, string target)
            {
                if ((source == null) || (target == null)) return 0.0;
                if ((source.Length == 0) || (target.Length == 0)) return 0.0;
                if (source == target) return 1.0;

                int stepsToSame = ComputeLevenshteinDistance(source, target);
                return (1.0 - ((double)stepsToSame / (double)Math.Max(source.Length, target.Length)));
            }


            //******************************************************************************************



            
        }

        public class StringRating
        {
            public string name;
            public int xCord;
            public int yCord;
            public double value;


        }

    }

    
}
